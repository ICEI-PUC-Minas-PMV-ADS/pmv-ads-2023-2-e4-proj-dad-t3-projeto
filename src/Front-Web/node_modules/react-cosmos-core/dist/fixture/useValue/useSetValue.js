import React from 'react';
import { findFixtureStateControl } from '../../fixtureState/controls.js';
import { createValue } from '../../fixtureState/createValues.js';
import { extendWithValue } from '../../fixtureState/extendWithValues.js';
import { FixtureContext } from '../FixtureContext.js';
export function useSetValue(inputName, defaultValue) {
    const { setFixtureState } = React.useContext(FixtureContext);
    return React.useCallback(stateChange => {
        setFixtureState(prevFs => {
            const currentValue = typeof stateChange === 'function'
                ? stateChange(
                // Types of fixture state values cannot be guaranteed at read
                // time, which means that tampering with the fixture state can
                // cause runtime errors
                getCurrentValueFromFixtureState(prevFs, inputName, defaultValue))
                : stateChange;
            return {
                ...prevFs,
                controls: {
                    ...prevFs.controls,
                    [inputName]: {
                        type: 'standard',
                        defaultValue: createValue(defaultValue),
                        currentValue: createValue(currentValue),
                    },
                },
            };
        });
    }, [setFixtureState, defaultValue, inputName]);
}
function getCurrentValueFromFixtureState(fixtureState, inputName, defaultValue) {
    const fsControl = findFixtureStateControl(fixtureState, inputName);
    return fsControl && fsControl.type === 'standard'
        ? extendWithValue(defaultValue, fsControl.currentValue)
        : defaultValue;
}
