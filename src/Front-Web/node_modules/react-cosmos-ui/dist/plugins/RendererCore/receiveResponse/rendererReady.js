import { postSelectFixtureRequest } from '../shared/postRequest.js';
import { getSelectedFixtureId } from '../shared/router.js';
export function receiveRendererReadyResponse(context, { payload }) {
    const { rendererId, fixtures, initialFixtureId } = payload;
    context.setState(stateUpdater, afterStateChanged);
    function stateUpdater(prevState) {
        // The first announced renderer becomes the primary one
        const primaryRendererId = prevState.primaryRendererId || rendererId;
        const isPrimaryRenderer = rendererId === primaryRendererId;
        const { connectedRendererIds, fixtureState } = prevState;
        return {
            ...prevState,
            connectedRendererIds: addToSet(connectedRendererIds, rendererId),
            primaryRendererId,
            fixtures,
            fixtureState: isPrimaryRenderer ? {} : fixtureState,
        };
    }
    function afterStateChanged() {
        if (initialFixtureId)
            selectInitialFixture(context, initialFixtureId);
        else
            selectFixtureFromUrlParams(context, rendererId);
        notifyRendererConnection(context, rendererId);
    }
}
function selectInitialFixture({ getMethodsOf }, fixtureId) {
    const router = getMethodsOf('router');
    router.selectFixture(fixtureId);
}
function selectFixtureFromUrlParams(context, rendererId) {
    const fixtureId = getSelectedFixtureId(context);
    if (fixtureId) {
        const { fixtureState } = context.getState();
        postSelectFixtureRequest(context, rendererId, fixtureId, fixtureState);
    }
}
function notifyRendererConnection({ getMethodsOf }, rendererId) {
    const notifications = getMethodsOf('notifications');
    notifications.pushTimedNotification({
        id: `renderer-connect-${rendererId}`,
        type: 'info',
        title: 'Renderer connected',
        info: 'Your fixtures are ready to use.',
    });
}
function addToSet(set, item) {
    return set.indexOf(item) === -1 ? [...set, item] : set;
}
