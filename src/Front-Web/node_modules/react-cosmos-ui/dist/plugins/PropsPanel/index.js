import React from 'react';
import { createPlugin } from 'react-plugin';
import { getFixtureExpansion, hasFsValues, updateElementExpansion, } from '../../components/ValueInputTree/index.js';
import { BlankState } from './BlankState.js';
import { PropsPanel } from './PropsPanel/index.js';
import { PROPS_TREE_EXPANSION_STORAGE_KEY } from './shared.js';
const { namedPlug, register } = createPlugin({
    name: 'propsPanel',
});
namedPlug('sidePanelRow', 'props', ({ pluginContext, slotProps }) => {
    const { fixtureId, fixtureState, onFixtureStateChange } = slotProps;
    const { fixtureExpansion, onElementExpansionChange } = useFixtureExpansion(pluginContext, fixtureId);
    return (React.createElement(PropsPanel, { fixtureState: fixtureState, fixtureExpansion: fixtureExpansion, onFixtureStateChange: onFixtureStateChange, onElementExpansionChange: onElementExpansionChange }));
});
// WARNING: This plug has to be aware of all control types and only show up
// when none is available
// TODO: Replace this with a more generic blank state (controls in general not
// just props)
namedPlug('sidePanelRow', 'blankState', ({ slotProps }) => {
    const { fixtureState } = slotProps;
    return shouldShowBlankState(fixtureState) ? React.createElement(BlankState, null) : null;
});
export { register };
if (process.env.NODE_ENV !== 'test')
    register();
const DEFAULT_TREE_EXPANSION = {};
function useFixtureExpansion(context, fixtureId) {
    const { getMethodsOf } = context;
    const storage = getMethodsOf('storage');
    const propsExpansion = storage.getItem(PROPS_TREE_EXPANSION_STORAGE_KEY) ||
        DEFAULT_TREE_EXPANSION;
    const fixtureExpansion = getFixtureExpansion(propsExpansion, fixtureId);
    const onElementExpansionChange = React.useCallback((elementId, treeExpansion) => {
        storage.setItem(PROPS_TREE_EXPANSION_STORAGE_KEY, updateElementExpansion(propsExpansion, fixtureId, elementId, treeExpansion));
    }, [storage, propsExpansion, fixtureId]);
    return {
        fixtureExpansion,
        onElementExpansionChange,
    };
}
function shouldShowBlankState(fixtureState) {
    // Don't show blank state until props (empty or not) have been read
    if (!fixtureState.props)
        return false;
    const hasProps = fixtureState.props.some(hasFsValues);
    if (hasProps)
        return false;
    const hasClassState = fixtureState.classState && fixtureState.classState.some(hasFsValues);
    if (hasClassState)
        return false;
    const hasControls = fixtureState.controls && Object.keys(fixtureState.controls).length > 0;
    if (hasControls)
        return false;
    return true;
}
