import { isEqual } from 'lodash-es';
import React, { Component } from 'react';
import { areNodesEqual } from 'react-cosmos-core';
export class ErrorCatch extends Component {
    state = {
        error: null,
    };
    componentDidCatch(error, info) {
        this.setState({
            error: `${error.message}\n${info.componentStack}`,
        });
    }
    componentDidUpdate(prevProps) {
        // A change in fixture (children) or fixture state signifies that the
        // problem that caused the current error might've been solved. If the error
        // persists, it will organically trigger the error state again in the next
        // update
        if (this.state.error &&
            (fixtureChanged(this.props.children, prevProps.children) ||
                fixtureStateChanged(this.props.fixtureState, prevProps.fixtureState))) {
            this.setState({ error: null });
            this.props.onErrorReset();
        }
    }
    render() {
        return this.state.error
            ? this.renderError(this.state.error)
            : this.props.children;
    }
    renderError(error) {
        // Don't render error details here in dev mode because react-error-overlay
        // takes care of it in a nicer way. We used to render both for a while but
        // it proved annoying. react-error-overlay has a slight delay and seeing
        // the same error reported twice feels clumsy.
        if (__DEV__) {
            return null;
        }
        // In static exports, however, where react-error-overlay is missing,
        // rendering plain error details is superior to showing a blank screen.
        return (React.createElement(React.Fragment, null,
            React.createElement("p", null,
                React.createElement("strong", null, "Ouch, something wrong!")),
            React.createElement("pre", null, error),
            React.createElement("p", null, "Check console for more info.")));
    }
}
function fixtureChanged(f1, f2) {
    return !areNodesEqual(f1, f2, true);
}
function fixtureStateChanged(fS1, fS2) {
    return !isEqual(fS1, fS2);
}
